(* ::Package:: *)

Begin["SymbolicTensor`temp`"];


With[
	{
		ScH = SymbolicTensor`SymbolicTensor | SymbolicTensor`SymbolicSum,
		
		ScR = SymbolicTensor`Scope`Replace,
		ScY = SymbolicTensor`Scope`Yield,
		ScT = SymbolicTensor`Scope`Transform
	},	
	
(**     Replace
 *
 *    - replace several dumb indexes one-by-one in part of x that is not
 *      shadowed by scopes which re-use these ghost indexes, i.e. replace only in real
 *      scope of these dumb indexes.
 *    - it handles {a\[Rule]b, b\[Rule]c} kind of replacement list with no problem.
 *    - algorithm logic demands that i to be verbatim, but it's the caller's responsibility
 *      to guarantee that. ( better not to call it directly )
 *)
 
(*	With[
		{ raw = SymbolicTensor`Scope`ReplaceR },
	
		raw[x_, (rtype : (Rule|RuleDelayed))[i_, ir_]] := (
			If[
				MatchQ[i, _Condition|_PatternTest|_Pattern], 
				Message[raw::pat, HoldForm[i]]
			];
			x /. {
				s : ScH[x1_, vrs_, ___]
					/; MemberQ[vrs, {i, ___}] :> s,
				rtype[i, ir]
			}
		);
			
		raw::pat = "pattern-like rule left side `1` is used";
		
		ScR[x_, rs_List] := Fold[raw, x, rs]; 
		
		ScR[x_, r : (_Rule|_RuleDelayed)] := raw[x, r];
	];*)
		
	ScR[x_, rplist_List] := (
		(*Print[HoldForm[x], HoldForm[rplist]];*)
		If[
			MemberQ[rplist, _Condition|_PatternTest|_Pattern],
			Message[ScR::pat, HoldForm[rplist]]
		];
		x /. Prepend[
			rplist,
			s : ScH[x1_, vrs_, ___] :> Block[
				{ rpl },
				
				rpl = Select[rplist, \[Not] MemberQ[vrs, {#[[1]], ___}]&];
				ScR[#, rpl] & /@ ScY[ s, rpl[[All, 2]] ]
			]
		]
	);
		
	ScR[x_, r : (_Rule|_RuleDelayed)] := ScR[x, {r}];
		
	ScR[x_, {}] := x;
		
	ScR::pat = "pattern-like rule left side `1` is used";


(**     Yield
 *
 *    - Yield[s, x] prepares 's' for intrusion of 'x', i.e. alternate 'vrs' in 's'
 *      so that free indexes in x won't be shielded by 'vrs'.
 *)
 
	With[
		{ FMQ = SymbolicTensor`Utility`FreeMemberQ },
		
		ScY[s : ScH[x1_, vrs_, ___], x_] := Block[
			{ yieldl = Cases[ vrs, 
				{i_, ___} /; FMQ[ x, Verbatim[i] ] :> Verbatim[i] -> Unique[] ] },
			
			ScR[ #, yieldl ] & /@ s
		];
	];

		
(**     Transform
 *
 *    - Transform[indexfunc][x] rename all dumb indexes in x with indexfunc. 
 *    - Transform's goal is to use a minimal number of distincted indexes.
 *)
	With[
		{
			DIL = SymbolicTensor`Utility`DumbIndexList,
			FMQ = SymbolicTensor`Utility`FreeMemberQ,
			rplg = SymbolicTensor`Scope`TransformReplacementListGenerator
		},
		
(**   - indexfunc[n] should return the n-th dumb index notation
 *    - rplg calls indexfunc sequencially, so indexfunc[n_] can be implemented as
 *
 *          indexfunc[1] := IndexFuncStart
 *          indexfunc[_] := IndexFuncNext
 *
 *      which is literally an iterator
 *)		
		rplg[indexfunc_][s_] := Block[
			{ n = 0, new },
			
			(
				While[ FMQ[ s, Verbatim[ new = indexfunc[ ++n ] ] ] ];
				Verbatim[#] -> new
			)& /@ DIL[ s ]
		];
			
		ScT[indexfunc_][ x_ ] := 
			x /. s : ScH[__] :> Block[
				{ rpl = rplg[indexfunc][s] },
				(ScT[indexfunc] @ ScR[#, rpl])& /@ s
			];
	];
];
			


End[];
